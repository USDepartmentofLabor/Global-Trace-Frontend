/* eslint-disable max-lines-per-function, max-lines */
import { Vue, Component, Prop, Ref } from 'vue-property-decorator';
import { get, isEmpty } from 'lodash';
import {
  importTaxonomyExploitations,
  uploadTaxonomyTranslationTemplate,
} from 'api/taxonomy-exploitation';
import { handleError } from 'components/Toast';

import {
  ImportActionEnum,
  TemplateActionEnum,
} from 'enums/taxonomy-exploitation';
import taxonomyExploitationModule from 'store/modules/taxonomy-exploitation';
import ImportFile from 'components/ImportFile';
import { UPLOAD_EXCEL_FILE, UPLOAD_TRANSLATE } from 'config/constants';
import DropdownMenu from 'components/DropdownMenu';
import {
  downloadTaxonomyExploitationTemplate,
  downloadTaxonomyTranslationTemplate,
} from 'utils/download-helper';
import { getShortToken } from 'api/auth';
import Button from 'components/FormUI/Button';
import * as Styled from './styled';

const ImportTaxonomyExploitationModal = () =>
  import('modals/ImportTaxonomyExploitationModal');
const ImportConfirmModal = () => import('modals/ImportConfirmModal');
const ValidationModal = () => import('modals/ValidationModal');
const IndicatorFilterModal = () => import('modals/IndicatorFilterModal');
const SetCategoryIconModal = () => import('modals/SetCategoryIconModal');

@Component
export default class HeaderAction extends Vue {
  @Ref('importFile')
  readonly importFileRef!: ImportFile;
  @Ref('importTranslation')
  readonly importTranslationRef!: ImportFile;

  @Prop({ required: true }) filterParams: TaxonomyManagement.FilterParams;
  @Prop({ required: true }) isEmptyData: boolean;
  @Prop({ required: true }) reloadData: () => void;
  @Prop({
    default: () => {
      //
    },
  })
  changeFilter: (params: TaxonomyManagement.FilterParams) => Promise<void>;

  get actionOptions(): App.DropdownMenuOption[] {
    return [
      {
        id: TemplateActionEnum.INDICATOR_LIST,
        name: this.$t('indicator_list'),
      },
      {
        id: TemplateActionEnum.TRANSLATION_FILE,
        name: this.$t('translations_file'),
      },
    ];
  }

  get isEmptyFilterParams(): boolean {
    return (
      !this.filterParams ||
      (isEmpty(this.filterParams.categoryIds) &&
        isEmpty(this.filterParams.indicatorIds) &&
        isEmpty(this.filterParams.subIndicatorIds))
    );
  }

  selectDownloadAction(option: App.DropdownMenuOption): void {
    switch (option.id) {
      case TemplateActionEnum.INDICATOR_LIST:
        this.downloadTemplate();
        break;
      case TemplateActionEnum.TRANSLATION_FILE:
        if (!this.isEmptyData) {
          this.downloadTranslation();
        }
        break;
    }
  }

  async downloadTemplate(): Promise<void> {
    try {
      const response = await getShortToken();
      const downloadUrl = downloadTaxonomyExploitationTemplate(
        response.shortToken,
      );
      window.open(downloadUrl, '_blank');
    } catch (error) {
      handleError(error as App.ResponseError);
    }
  }

  async downloadTranslation(): Promise<void> {
    try {
      const response = await getShortToken();
      const downloadUrl = downloadTaxonomyTranslationTemplate(
        response.shortToken,
      );
      window.open(downloadUrl, '_blank');
    } catch (error) {
      handleError(error as App.ResponseError);
    }
  }

  onValidateTaxonomy(
    file: App.SelectedFile,
  ): Promise<Files.UploadedFileResponse> {
    return new Promise((resolve, reject) => {
      taxonomyExploitationModule.uploadFile({
        data: { file },
        callback: {
          onSuccess: (response: Files.UploadedFileResponse) => {
            resolve(response);
          },
          onFailure: (error: App.ResponseError) => {
            handleError(error);
            reject();
          },
        },
      });
    });
  }

  showImportTaxonomyExploitationModal(data: Files.UploadedFileResponse): void {
    if (data && data.validatedItemCount < data.totalItems) {
      this.$modal.show(
        ImportTaxonomyExploitationModal,
        {
          validateFile: this.onValidateTaxonomy,
          validatedFile: this.showImportTaxonomyExploitationModal,
          importTaxonomyExploitation: this.openImportConfirmModal,
        },
        {
          name: 'ImportTaxonomyExploitationModal',
          width: '380px',
          height: 'auto',
          clickToClose: false,
          classes: 'modal-center',
        },
      );
    } else {
      this.openImportConfirmModal();
    }
  }

  openImportConfirmModal(): void {
    if (this.isEmptyData) {
      this.onImportTaxonomyExploitation(ImportActionEnum.ADD);
    } else {
      this.$modal.show(
        ImportConfirmModal,
        {
          icon: 'file_check',
          iconSize: '44',
          message: this.$t('import_file_confirmation_message'),
          note: this.$t('this_action_cannot_be_undone'),
          onImport: this.onImportTaxonomyExploitation,
        },
        { width: '374px', height: 'auto', clickToClose: false },
      );
    }
  }

  async onImportTaxonomyExploitation(action: ImportActionEnum): Promise<void> {
    try {
      const fileId = get(
        taxonomyExploitationModule.uploadedResponse,
        'fileId',
        '',
      );
      const params: TaxonomyManagement.ImportParams = {
        action,
      };
      const { validationErrors } = await importTaxonomyExploitations(
        fileId,
        params,
      );
      if (!isEmpty(validationErrors)) {
        this.showValidationModal(validationErrors);
      } else {
        this.$toast.success(this.$t('successfully_updated_indicator_list'));
        this.$modal.hide('ImportConfirmModal');
      }
      taxonomyExploitationModule.resetFileUpload();
      this.reloadData();
    } catch (error) {
      handleError(error as App.ResponseError);
    }
  }

  showValidationModal(validationErrors: Files.ValidationError[]): void {
    this.$modal.show(
      ValidationModal,
      {
        validationErrors,
        numberErrors: validationErrors.length,
      },
      {
        width: '459px',
        height: 'auto',
        clickToClose: false,
      },
    );
  }

  showIndicatorFilterModal(): void {
    this.$modal.show(
      IndicatorFilterModal,
      {
        filterParams: this.filterParams,
        onUpdate: this.changeFilter,
      },
      {
        width: '550px',
        height: 'auto',
        clickToClose: false,
      },
    );
  }

  async onValidateTranslation(file: App.SelectedFile): Promise<void> {
    try {
      const { validationErrors } = await uploadTaxonomyTranslationTemplate({
        file,
      });
      if (validationErrors.length > 0) {
        this.showValidationModal(validationErrors);
      } else {
        this.reloadData();
        this.$toast.success(this.$t('successfully_uploaded_file'));
      }
    } catch (error) {
      handleError(error as App.ResponseError);
    }
  }

  selectUploadAction(option: App.DropdownMenuOption): void {
    if (
      !(this.isEmptyData && option.id === TemplateActionEnum.TRANSLATION_FILE)
    ) {
      let ref: App.Any = null;
      switch (option.id as TemplateActionEnum) {
        case TemplateActionEnum.INDICATOR_LIST:
          ref = this.importFileRef.uploadComponentRef;
          break;
        case TemplateActionEnum.TRANSLATION_FILE:
          ref = this.importTranslationRef.uploadComponentRef;
          break;
      }
      ref.$children[0].$el.click();
    }
  }

  openCategoryIconModal() {
    this.$modal.show(
      SetCategoryIconModal,
      {},
      {
        classes: 'fromRight',
        styles: 'border-radius: 0;',
        width: 600,
        height: '100%',
        shiftX: 1,
        shiftY: 0,
        clickToClose: false,
      },
    );
  }

  renderActionOption(option: App.DropdownMenuOption): JSX.Element {
    const isDisable =
      this.isEmptyData && option.id === TemplateActionEnum.TRANSLATION_FILE;
    return <Styled.Label isDisable={isDisable}>{option.name}</Styled.Label>;
  }

  render(): JSX.Element {
    return (
      <fragment>
        {!this.isEmptyData && (
          <Button
            variant={this.isEmptyFilterParams ? 'outlinePrimary' : 'primary'}
            icon="filter"
            click={this.showIndicatorFilterModal}
          />
        )}
        <DropdownMenu
          options={this.actionOptions}
          selectOption={this.selectDownloadAction}
          scopedSlots={{
            menuOption: ({ option }: { option: App.DropdownMenuOption }) =>
              this.renderActionOption(option),
          }}
        >
          <Button
            variant="outlinePrimary"
            label={this.$t('templates')}
            icon="download"
          />
        </DropdownMenu>
        <DropdownMenu
          options={this.actionOptions}
          selectOption={this.selectUploadAction}
          scopedSlots={{
            menuOption: ({ option }: { option: App.DropdownMenuOption }) =>
              this.renderActionOption(option),
          }}
        >
          <Button
            variant="primary"
            label={this.$t('upload_files')}
            icon="export"
          />
        </DropdownMenu>
        {!this.isEmptyData && (
          <Button
            variant="primary"
            label={this.$t('set_category_icons')}
            icon="check_square"
            click={this.openCategoryIconModal}
          />
        )}
        <Styled.HiddenInput>
          <ImportFile
            ref="importFile"
            accept={UPLOAD_EXCEL_FILE.EXTENSIONS}
            validateFile={this.onValidateTaxonomy}
            validatedFile={this.showImportTaxonomyExploitationModal}
          />
          <ImportFile
            ref="importTranslation"
            inputId="importTranslation"
            accept={UPLOAD_TRANSLATE.ACCEPTED}
            validateFile={this.onValidateTranslation}
          />
        </Styled.HiddenInput>
      </fragment>
    );
  }
}

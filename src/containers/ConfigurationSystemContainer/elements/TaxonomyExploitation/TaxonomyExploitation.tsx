/* eslint-disable max-lines-per-function, max-lines */
import { Vue, Component, Watch } from 'vue-property-decorator';
import { get, debounce, isEmpty } from 'lodash';
import { SpinLoading } from 'components/Loaders';
import requestModule from 'store/modules/request';
import AppModule from 'store/modules/app';
import {
  deleteTaxonomyExploitation,
  getTaxonomyExploitations,
} from 'api/taxonomy-exploitation';
import { handleError } from 'components/Toast';
import Input from 'components/FormUI/Input';
import DataTable from 'components/DataTable/DataTable';
import Button from 'components/FormUI/Button';
import { getShortToken } from 'api/auth';
import { downloadTaxonomyExploitationTemplate } from 'utils/download-helper';
import { SortType } from 'enums/app';
import * as Styled from './styled';

const TaxonomyExploitationModal = () =>
  import('modals/TaxonomyExploitationModal');
const ConfirmModal = () => import('modals/ConfirmModal');
const UploadTaxonomyModal = () => import('modals/UploadTaxonomyModal');
const UploadTaxonomyTranslationModal = () =>
  import('modals/UploadTaxonomyTranslationModal');

@Component
export default class Taxonomy extends Vue {
  private isLoading = true;
  private isGetting: boolean = false;
  private isEmptyData: boolean = true;
  private data: TaxonomyManagement.TaxonomyExploitation[] = [];
  private search: string = '';
  private sortInfo: App.SortInfo = {
    sort: SortType.ASC,
    sortKey: 'indicator',
  };
  private requestParams: App.RequestParams = null;
  private pagination: App.Pagination = {
    total: 1,
    lastPage: 1,
    perPage: 20,
    currentPage: 1,
  };

  get columns(): App.DataTableColumn[] {
    return [
      {
        label: this.$t('category'),
        field: 'category',
        sortable: true,
        sortKey: 'category',
      },
      {
        label: this.$t('indicator'),
        field: 'indicator',
        sortable: true,
        sortKey: 'indicator',
      },
      {
        label: this.$t('sub_indicator'),
        field: 'subIndicator',
        sortable: true,
        sortKey: 'subIndicator',
      },
      {
        label: this.$t('risk_severity'),
        field: 'riskSeverity',
        sortable: true,
        sortKey: 'riskSeverity',
      },
      {
        label: '',
        field: '',
        width: '70px',
      },
    ];
  }

  get currentLocale(): string {
    return AppModule.locale;
  }

  @Watch('currentLocale')
  onChangeCurrentLocale() {
    this.initData();
  }

  created() {
    this.initData();
    this.getIndicators();
    this.onDebouncedSearch = debounce(this.onDebouncedSearch, 500);
  }

  initData(): void {
    const { sort, sortKey } = this.sortInfo;
    this.requestParams = {
      sortFields: `${sortKey}:${sort}`,
    };
    this.getList(true, this.requestParams);
  }

  getIndicators(): void {
    requestModule.getIndicators({
      callback: {
        onFailure: (error: App.ResponseError) => {
          handleError(error);
        },
      },
    });
  }

  reloadData() {
    const { sort, sortKey } = this.sortInfo;
    this.requestParams = {
      key: this.search,
      sortFields: `${sortKey}:${sort}`,
    };
    this.getList(false, this.requestParams);
  }

  onDebouncedSearch(value: string) {
    this.requestParams = {
      page: 1,
      key: value,
    };
    this.getList(false, this.requestParams);
  }

  async getList(
    isFirstLoad: boolean,
    params: TaxonomyManagement.RequestParams,
  ) {
    try {
      this.isLoading = isFirstLoad;
      this.isGetting = true;
      const requestParams = { ...this.requestParams, ...params };
      const { items, ...pagination } = await getTaxonomyExploitations(
        requestParams,
      );
      this.data = items;
      this.pagination = pagination;

      this.isEmptyData = isFirstLoad && isEmpty(this.data);
    } catch (error) {
      handleError(error as App.ResponseError);
    } finally {
      this.isGetting = false;
      this.isLoading = false;
    }
  }

  handleInputSearch(value: string): void {
    this.search = value;
    this.onDebouncedSearch(this.search);
  }

  sortColumn(key: string, type: string): void {
    this.sortInfo = {
      sort: type,
      sortKey: key,
    };
    this.requestParams = {
      ...this.requestParams,
      sortFields: `${key}:${type}`,
    };
    this.getList(false, this.requestParams);
  }

  async downloadTemplate(): Promise<void> {
    try {
      const response = await getShortToken();
      const downloadUrl = downloadTaxonomyExploitationTemplate(
        response.shortToken,
      );
      window.open(downloadUrl, '_blank');
    } catch (error) {
      handleError(error as App.ResponseError);
    }
  }

  pageOnChange(page: number): void {
    this.requestParams.page = page;
    this.getList(false, this.requestParams);
  }

  openTaxonomyExploitationModal(item: TaxonomyManagement.TaxonomyExploitation) {
    this.$modal.show(
      TaxonomyExploitationModal,
      {
        taxonomyExploitation: item,
        onSuccess: this.reloadData,
      },
      {
        name: 'TaxonomyExploitationModal',
        width: '497px',
        height: 'auto',
        clickToClose: false,
      },
    );
  }

  openDeleteModal(item: TaxonomyManagement.TaxonomyExploitation): void {
    this.$modal.show(
      ConfirmModal,
      {
        icon: 'delete',
        iconSize: '44',
        message: this.$t('delete_row_message'),
        note: this.$t('this_action_cannot_be_undone'),
        confirmLabel: this.$t('common.action.yes_delete'),
        confirmButtonVariant: 'danger',
        cancelLabel: this.$t('common.action.cancel'),
        onConfirm: () =>
          this.deleteTaxonomyExploitation(item.id, item.subIndicator.id),
      },
      { width: '410px', height: 'auto', clickToClose: false, adaptive: true },
    );
  }

  async deleteTaxonomyExploitation(
    indicatorId: string,
    subIndicatorId: string,
  ): Promise<void> {
    try {
      await deleteTaxonomyExploitation(indicatorId, subIndicatorId);
      this.initData();
      this.$toast.success(this.$t('successfully_deleted'));
    } catch (error) {
      handleError(error as App.ResponseError);
    }
  }

  openUploadTranslationModal(): void {
    this.$modal.show(
      UploadTaxonomyTranslationModal,
      {
        onSuccess: this.initData,
      },
      {
        name: 'UploadTaxonomyFileModal',
        classes: 'fromRight',
        styles: 'border-radius: 0;',
        width: 600,
        height: '100%',
        shiftX: 1,
        clickToClose: false,
      },
    );
  }

  openUploadModal(): void {
    this.$modal.show(
      UploadTaxonomyModal,
      {
        isEmptyData: this.isEmptyData,
        onSuccess: this.initData,
      },
      {
        name: 'UploadTaxonomyModal',
        classes: 'fromRight',
        styles: 'border-radius: 0;',
        width: 600,
        height: '100%',
        shiftX: 1,
        clickToClose: false,
      },
    );
  }

  renderEmptyData(): JSX.Element {
    if (this.isLoading) {
      return <SpinLoading />;
    }
    return (
      <Styled.EmptyContainer>
        <Styled.EmptyImage />
        <Styled.EmptyText>
          {this.$t('there_are_nothing_to_show')}
        </Styled.EmptyText>
        <Styled.EmptyActions>
          <Button
            icon="download"
            width="100%"
            type="button"
            variant="outlinePrimary"
            label={this.$t('download_template')}
            click={() => this.downloadTemplate()}
          />
          <Button
            icon="export"
            width="100%"
            variant="primary"
            label={this.$t('define_indicator_list')}
            click={() => this.openUploadModal()}
          />
        </Styled.EmptyActions>
      </Styled.EmptyContainer>
    );
  }

  renderRowItem(item: TaxonomyManagement.TaxonomyExploitation): JSX.Element {
    return (
      <Styled.Tr>
        <Styled.Td>{get(item, 'category.name')}</Styled.Td>
        <Styled.Td>{item.name}</Styled.Td>
        <Styled.Td>{get(item, 'subIndicator.name')}</Styled.Td>
        <Styled.Td>{get(item, 'subIndicator.riskSeverity')}</Styled.Td>
        {this.renderActions(item)}
      </Styled.Tr>
    );
  }

  renderActions(item: TaxonomyManagement.TaxonomyExploitation): JSX.Element {
    return (
      <Styled.Td>
        <Styled.RowActions>
          <Button
            label={this.$t('edit')}
            icon="edit"
            variant="transparentSecondary"
            size="small"
            iconSize="20"
            click={() => this.openTaxonomyExploitationModal(item)}
          />
          <Button
            label={this.$t('delete')}
            icon="delete"
            variant="transparentSecondary"
            size="small"
            iconSize="20"
            click={() => {
              this.openDeleteModal(item);
            }}
          />
        </Styled.RowActions>
      </Styled.Td>
    );
  }

  renderTableHeader(): JSX.Element {
    return (
      <Styled.TableHeader>
        <Input
          height="40px"
          name="search"
          size="large"
          value={this.search}
          placeholder={this.$t('search_for_indicator_sub_indicator')}
          changeValue={(value: string) => {
            this.handleInputSearch(value);
          }}
          prefixIcon="search"
          suffixIcon={this.search ? 'remove' : ''}
          clickSuffixIcon={() => this.handleInputSearch('')}
        />
        <Button
          icon="export"
          width="100%"
          variant="primary"
          label={this.$t('define_indicator_list')}
          click={() => this.openUploadModal()}
        />
        <Button
          icon="export"
          label={this.$t('upload_translation')}
          width="100%"
          click={() => this.openUploadTranslationModal()}
        />
      </Styled.TableHeader>
    );
  }

  renderTable(): JSX.Element {
    return (
      <DataTable
        numberRowLoading={10}
        isLoading={this.isGetting}
        columns={this.columns}
        data={this.data}
        pagination={this.pagination}
        sortColumn={this.sortColumn}
        pageOnChange={this.pageOnChange}
        scopedSlots={{
          tableRow: ({
            item,
          }: {
            item: TaxonomyManagement.TaxonomyExploitation;
          }) => this.renderRowItem(item),
        }}
      />
    );
  }

  renderContent(): JSX.Element {
    if (this.isLoading) {
      return <SpinLoading />;
    }
    if (this.isEmptyData) {
      return this.renderEmptyData();
    }
    return (
      <fragment>
        {this.renderTableHeader()}
        {this.renderTable()}
      </fragment>
    );
  }

  render(): JSX.Element {
    return <Styled.Wrapper>{this.renderContent()}</Styled.Wrapper>;
  }
}

/* eslint-disable max-lines-per-function, max-lines */
import { Vue, Component, Watch } from 'vue-property-decorator';
import { get, debounce, isEmpty, isEqual } from 'lodash';
import { SpinLoading } from 'components/Loaders';
import requestModule from 'store/modules/request';
import AppModule from 'store/modules/app';
import {
  deleteTaxonomyExploitation,
  getTaxonomyExploitations,
} from 'api/taxonomy-exploitation';
import { handleError } from 'components/Toast';
import Input from 'components/FormUI/Input';
import DataTable from 'components/DataTable/DataTable';
import Button from 'components/FormUI/Button';
import { SortType } from 'enums/app';
import * as Styled from './styled';
import HeaderAction from './elements/HeaderAction/HeaderAction';

const TaxonomyExploitationModal = () =>
  import('modals/TaxonomyExploitationModal');
const ConfirmModal = () => import('modals/ConfirmModal');

@Component
export default class Taxonomy extends Vue {
  private isLoading = true;
  private isGetting: boolean = false;
  private isEmptyData: boolean = true;
  private data: TaxonomyManagement.TaxonomyExploitation[] = [];
  private search: string = '';
  private sortInfo: App.SortInfo = {
    sort: SortType.ASC,
    sortKey: 'indicator',
  };
  private requestParams: App.RequestParams = null;
  private pagination: App.Pagination = {
    total: 1,
    lastPage: 1,
    perPage: 20,
    currentPage: 1,
  };
  private filterParams: TaxonomyManagement.FilterParams = {
    categoryIds: [],
    indicatorIds: [],
    subIndicatorIds: [],
  };

  get columns(): App.DataTableColumn[] {
    return [
      {
        label: this.$t('category'),
        field: 'category',
        sortable: true,
        sortKey: 'category',
      },
      {
        label: this.$t('indicator'),
        field: 'indicator',
        sortable: true,
        sortKey: 'indicator',
      },
      {
        label: this.$t('sub_indicator'),
        field: 'subIndicator',
        sortable: true,
        sortKey: 'subIndicator',
      },
      {
        label: this.$t('risk_severity'),
        field: 'riskSeverity',
        sortable: true,
        sortKey: 'riskSeverity',
      },
      {
        label: '',
        field: '',
        width: '70px',
      },
    ];
  }

  get currentLocale(): string {
    return AppModule.locale;
  }

  @Watch('currentLocale')
  onChangeCurrentLocale() {
    this.reloadData();
  }

  created() {
    this.getCategory(() => {
      this.getIndicators(() => {
        this.getSubIndicators(this.filterParams.indicatorIds, () => {
          this.initData();
          this.onDebouncedSearch = debounce(this.onDebouncedSearch, 500);
        });
      });
    });
  }

  initData(isFirstLoad: boolean = true): void {
    const { sort, sortKey } = this.sortInfo;
    this.requestParams = {
      sortFields: `${sortKey}:${sort}`,
    };
    this.getList(isFirstLoad, this.requestParams);
  }

  getCategory(onSuccess: () => void): void {
    requestModule.getCategories({
      callback: {
        onSuccess: onSuccess,
        onFailure: (error: App.ResponseError) => {
          handleError(error);
        },
      },
    });
  }

  getIndicators(onSuccess: () => void): void {
    requestModule.getIndicators({
      callback: {
        onSuccess: onSuccess,
        onFailure: (error: App.ResponseError) => {
          handleError(error);
        },
      },
    });
  }

  getSubIndicators(indicatorIds: string[], onFinish: () => void) {
    requestModule.getSubIndicators({
      parentIds: indicatorIds,
      callback: {
        onFailure: () => {
          this.filterParams.subIndicatorIds = [];
        },
        onFinish: onFinish,
      },
    });
  }

  reloadData() {
    this.getCategory(() => {
      this.getIndicators(() => {
        this.getSubIndicators(this.filterParams.indicatorIds, () => {
          this.initData(false);
        });
      });
    });
  }

  onDebouncedSearch(value: string) {
    this.requestParams = {
      page: 1,
      key: value,
    };
    this.getList(false, this.requestParams);
  }

  updateFilterParams() {
    let categoryIds = get(this.filterParams, 'categoryIds', []);
    categoryIds = categoryIds.filter((categoryId) =>
      requestModule.categories.some(({ id }) => id === categoryId),
    );
    let indicatorIds = get(this.filterParams, 'indicatorIds', []);
    indicatorIds = indicatorIds.filter((indicatorId) =>
      requestModule.indicators.some(({ id }) => id === indicatorId),
    );
    let subIndicatorIds = get(this.filterParams, 'subIndicatorIds', []);
    subIndicatorIds = subIndicatorIds.filter((subIndicatorId) =>
      requestModule.subIndicators.some(({ id }) => id === subIndicatorId),
    );
    this.filterParams = {
      categoryIds,
      indicatorIds,
      subIndicatorIds,
    };
  }

  async getList(
    isFirstLoad: boolean,
    params: TaxonomyManagement.RequestParams,
  ) {
    try {
      this.isLoading = isFirstLoad;
      this.isGetting = true;
      this.updateFilterParams();
      const requestParams = {
        ...this.requestParams,
        ...this.filterParams,
        ...params,
      };
      const { items, ...pagination } = await getTaxonomyExploitations(
        requestParams,
      );
      this.data = items;
      this.pagination = pagination;

      this.isEmptyData = isFirstLoad && isEmpty(this.data);
    } catch (error) {
      handleError(error as App.ResponseError);
    } finally {
      this.isGetting = false;
      this.isLoading = false;
    }
  }

  handleInputSearch(value: string): void {
    this.search = value;
    this.onDebouncedSearch(this.search);
  }

  sortColumn(key: string, type: string): void {
    this.sortInfo = {
      sort: type,
      sortKey: key,
    };
    this.requestParams = {
      ...this.requestParams,
      sortFields: `${key}:${type}`,
    };
    this.getList(false, this.requestParams);
  }

  pageOnChange(page: number): void {
    this.requestParams.page = page;
    this.getList(false, this.requestParams);
  }

  onUpdateFilter(params: TaxonomyManagement.FilterParams) {
    if (!isEqual(this.filterParams, params)) {
      this.requestParams.page = 1;
      this.filterParams = params;
      this.getList(false, this.requestParams);
    }
  }

  openTaxonomyExploitationModal(item: TaxonomyManagement.TaxonomyExploitation) {
    this.$modal.show(
      TaxonomyExploitationModal,
      {
        taxonomyExploitation: item,
        onSuccess: this.reloadData,
      },
      {
        name: 'TaxonomyExploitationModal',
        width: '497px',
        height: 'auto',
        clickToClose: false,
      },
    );
  }

  openDeleteModal(item: TaxonomyManagement.TaxonomyExploitation): void {
    this.$modal.show(
      ConfirmModal,
      {
        icon: 'delete',
        iconSize: '44',
        message: this.$t('delete_row_message'),
        note: this.$t('this_action_cannot_be_undone'),
        confirmLabel: this.$t('common.action.yes_delete'),
        confirmButtonVariant: 'danger',
        cancelLabel: this.$t('common.action.cancel'),
        onConfirm: () =>
          this.deleteTaxonomyExploitation(item.id, item.subIndicator.id),
      },
      { width: '410px', height: 'auto', clickToClose: false, adaptive: true },
    );
  }

  async deleteTaxonomyExploitation(
    indicatorId: string,
    subIndicatorId: string,
  ): Promise<void> {
    try {
      await deleteTaxonomyExploitation(indicatorId, subIndicatorId);
      this.reloadData();
      this.$toast.success(this.$t('successfully_deleted'));
    } catch (error) {
      handleError(error as App.ResponseError);
    }
  }

  renderEmptyData(): JSX.Element {
    if (this.isLoading) {
      return <SpinLoading />;
    }
    return (
      <Styled.EmptyContainer>
        <Styled.EmptyImage />
        <Styled.EmptyText>
          {this.$t('there_are_nothing_to_show')}
        </Styled.EmptyText>
        <Styled.EmptyActions>{this.renderHeaderAction()}</Styled.EmptyActions>
      </Styled.EmptyContainer>
    );
  }

  renderRowItem(item: TaxonomyManagement.TaxonomyExploitation): JSX.Element {
    return (
      <Styled.Tr>
        <Styled.Td>{get(item, 'category.name')}</Styled.Td>
        <Styled.Td>{item.name}</Styled.Td>
        <Styled.Td>{get(item, 'subIndicator.name')}</Styled.Td>
        <Styled.Td>{get(item, 'subIndicator.riskSeverity')}</Styled.Td>
        {this.renderActions(item)}
      </Styled.Tr>
    );
  }

  renderActions(item: TaxonomyManagement.TaxonomyExploitation): JSX.Element {
    return (
      <Styled.Td>
        <Styled.RowActions>
          <Button
            label={this.$t('edit')}
            icon="edit"
            variant="transparentSecondary"
            size="small"
            iconSize="20"
            click={() => this.openTaxonomyExploitationModal(item)}
          />
          <Button
            label={this.$t('delete')}
            icon="delete"
            variant="transparentSecondary"
            size="small"
            iconSize="20"
            click={() => {
              this.openDeleteModal(item);
            }}
          />
        </Styled.RowActions>
      </Styled.Td>
    );
  }

  renderHeaderAction(): JSX.Element {
    return (
      <HeaderAction
        filterParams={this.filterParams}
        isEmptyData={this.isEmptyData}
        reloadData={this.reloadData}
        changeFilter={this.onUpdateFilter}
      />
    );
  }

  renderTableHeader(): JSX.Element {
    return (
      <Styled.TableHeader>
        <Input
          height="40px"
          name="search"
          size="large"
          value={this.search}
          placeholder={this.$t('search_for_indicator_sub_indicator')}
          changeValue={(value: string) => {
            this.handleInputSearch(value);
          }}
          prefixIcon="search"
          suffixIcon={this.search ? 'remove' : ''}
          clickSuffixIcon={() => this.handleInputSearch('')}
        />
        {this.renderHeaderAction()}
      </Styled.TableHeader>
    );
  }

  renderTable(): JSX.Element {
    return (
      <DataTable
        numberRowLoading={10}
        isLoading={this.isGetting}
        columns={this.columns}
        data={this.data}
        pagination={this.pagination}
        sortColumn={this.sortColumn}
        pageOnChange={this.pageOnChange}
        scopedSlots={{
          tableRow: ({
            item,
          }: {
            item: TaxonomyManagement.TaxonomyExploitation;
          }) => this.renderRowItem(item),
        }}
      />
    );
  }

  renderContent(): JSX.Element {
    if (this.isLoading) {
      return <SpinLoading />;
    }
    if (this.isEmptyData) {
      return this.renderEmptyData();
    }
    return (
      <fragment>
        {this.renderTableHeader()}
        {this.renderTable()}
      </fragment>
    );
  }

  render(): JSX.Element {
    return <Styled.Wrapper>{this.renderContent()}</Styled.Wrapper>;
  }
}
